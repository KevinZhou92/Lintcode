```
@Copyright:LintCode
@Author:   zhou21
@Problem:  http://www.lintcode.com/problem/word-ladder-ii
@Language: Markdown
@Datetime: 17-03-14 06:32
```

1.本题要求找到所有的最短路径的组合，那么这种找所有的可能性的题目肯定是深度优先搜索
2.由于这里要找到所有组合并且记录组合当中的每个数据，那么要求我们先对原始数据做宽度优先搜索，这样获得所有词汇与其对应的可能变形成为的词汇的一个map，然后还要一个所有词汇和其所变形成为的词汇的一个最短路径， 在这个过程中我们使用了辅助函数来计算所有可能的组合，如果字典里存在变形后的单词，就把这个单词加入到可能的list中
3.**深度优先搜索选择从终点开始，这是一个很巧妙地思路，因为在距离的map中，我们记录了从起点到终点词的最短距离，所以end word对应的距离就是我们所需要的最短距离，那么从这个最短距离出发，每次我们找当前次的可能变形，然后去检验和当前距离是不是相差一个单位，采用了回溯的思路，如果从起点出发的话，没有办法记录最短距离，而从终点出发就解决了这个问题，每次只继续搜索和当前点距离相差1的点，如果在这个过程中找到了起始点，那么问题就解决了**
4.在dfs中的判断条件：
```java
if (dist.get(next) == dist.get(end) - 1 && dist.containsKey(next)) {
	dfs(map, dist, start, next, path, results);
	}
```