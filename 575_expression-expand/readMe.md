```
@Copyright:LintCode
@Author:   zhou21
@Problem:  http://www.lintcode.com/problem/expression-expand
@Language: Markdown
@Datetime: 17-04-22 00:57
```

**典型的非递归栈和递归DFS的题目**
1.这道题目很有代表性，设计了字符串的操作，char类型的操作，以及Object类型和子类型的互相转换，特别是`instanceof`方法,a instanceof A,判断“一个对象是否是一个类的实例”。作为操作符instanceof不可以直接在最前面！取非（比如&gt;=这种也是），而是用 a instanceof A == false之类的判断
2.非递归的思路就是从前往后依次处理字符串的每个字符，如果是数字，就一直累加求出数值，注意这里因为是字符，采用的ascii码的值代表数字字符。所以要转化为数值的话直接减去‘0’的ascii码，就可以得到十进制的值，如果遇到‘【’，就代表数字值确定，压入栈中，归0，如果遇到‘】’，就将最近的一个【】中的字符展开，注意这里‘【’和‘】’是不会被压入栈中的
3.这里要注意处理最终字符串的顺序问题，我们第一遍扫描字符串是从内而外展开字符串的，从头到尾加入需要复制多次的字符串，那么直接pop顺序是错误的，需要reverse弹出的字符串，然后按照数值复制相应次数后加入栈中，代表当前层次处理完毕，然后加入栈中，最后把处理完成的栈中的值弹出reverse即可
4.**递归的思路很有代表性**，还是从递归三要素来思考，递归的入口，定义和拆解，要记住递归就是把大问题化为相同性质的小问题，然后设置好出口，让问题自己解决自己，这里注意我们是把要展开的字符串化解为一个个小的要展开的相同格式的字符串，然后不断展开得到最后的值，注意这里设置一个条件判断是否嵌套，如果嵌套了就把当前字符加入子串，没有的话就直接展开，判断是否嵌套是根据当前出现的中括号对数来决定的
```
else if (c == ']') {
	parent--;
	if (parent == 0) {
		String expand = expressionExpand(substring);
		for (int i = 0; i < number; i++) {
			sb.append(expand);
		}
		number = 0;
		substring = "";
}
```
注意这里，每次展开之后一定要重置展开的次数的值和子串，考虑这种`3[2[ad]3[pf]]xyz`情况, 当前面的展开完之后，如果不重置，那么会导致同一递归层次的[ad]后面的字符串[pf]也被扩展很多次，导致结果错误，在递归的过程中一定保证每个括号处理完之后要重置计数器和子串