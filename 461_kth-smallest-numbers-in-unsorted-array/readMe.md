```
@Copyright:LintCode
@Author:   zhou21
@Problem:  http://www.lintcode.com/problem/kth-smallest-numbers-in-unsorted-array
@Language: Markdown
@Datetime: 17-04-07 23:30
```

1. 这里直接采用了quick select，也就是把quick sort中的partition单独拿出来对数组进行一个操作
2.  这里使用了数组当前的中点来作为pivot point，这是个很trick的方法，注意边界判定，然后每次把小于等于pivot的点交换到数组左边，大于等于pivot的点交换到数组右边，然后这样一定可以保证数组按照pivot的值分成两部分，左边的一定大于等于右边的值,**注意这种情况下左右两部分并不一定是完全有序的**, 也可以使用数组第一个元素来切分，注意处理元素和切分元素相等的情况即可
3. 按照pivot来区分总共有三种情况, 当left指针所指向的数正好等于pivot的值时，left指针会停住，对于right指针同理，这样的话，当right < k < left时，我们直接返回，如果不是，按照相应情况处理，最后可能left和right为相邻或者隔了一个数，那么我们要按照这三种情况判断k属于哪个区间
    * 	第k个值在左边分区
    * 	第k个值在右边分区
    * 	第k个值就是pivot point 

4. 注意每个情况的分析, 要保证左边的元素小于等于pivot，右边的元素大于等于pivot，也就是扫描的时候左边只有完全小于pivot才能move on，右边就是相反情况。为什么不用大于等于或者小于等于是因为我们要确保数组被正确切分，保证切分点左边小于等于切分点，右边大于等于切分点
5. 快速排序的核心就是先切分，每次切分点到位之后，切分点左边的永远小于等于当前切分点，切分点右边的大于等于当前切分点，然后对左右分别处理，如果当前切分点的位置正好是我们需要的，那么直接返回这个点即可