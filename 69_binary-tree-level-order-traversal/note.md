```
@Copyright:LintCode
@Author:   zhou21
@Problem:  http://www.lintcode.com/problem/binary-tree-level-order-traversal
@Language: Markdown
@Datetime: 17-02-11 16:27
```

1.很典型的宽度优先搜索，使用队列，分层遍历，这里有三种使用队列的方式：
(1). 统计当前队列长度，表示当前层次元素有多少，将这些元素依次加入到当前层结果中，并且将这一层的子节点，也就是下一层的元素也加入到队列中，因为队列是先进先出，所以每一次只会输出当前层次的元素
(2). 采用两个队列，在遍历当前队列中元素时，将下层的元素存到另外一个队列中去，然后在遍历结束之后将将当前结果加入最后的result中，然后再将两个队列交换，这样循环的还是第一个队列，注意细节即可，没有难度
(3).  还可以在队列中添加一个null的点来作为每层之间的分隔符，这样每次队列中弹出这个识别符时，说明当前层次的所有点已经弹出队列了，而且也已经将后继元素全部添加到队列中，那么就继续在这些后继元素的尾部加上null来和下面一层的分别，以此类推，同事将目前的列表加入结果，重置列表，然后在这个循环中还要检查是不是加入了元素，如果列表大小为0，就可以终止程序了
2.也可以采用深度优先搜索, 注意对深度优先的递归函数做一些改动，增加记录当前层数的参数和所需要遍历的层数的数据，这样深度优先搜索只会选取当前层次的数据加入路径中，终止条件设置为遍历时无法获得任何元素，这样就直接退出循环，这里使用了循环配合递归，每次循环只递归单层元素