```
@Copyright:LintCode
@Author:   zhou21
@Problem:  http://www.lintcode.com/problem/maximum-average-subarray
@Language: Markdown
@Datetime: 17-01-31 01:30
```

1.这个题目比较有难度，和copy book的题目类似，都是先找到最终答案的可能范围，然后在这个范围之内二分搜索
2.由于是求最大平均值，所以可以将数组中每个元素减去当前我们假定的平均值，然后加起来求和，将结果存在一个独立的数组中，数组中的每个元素是从第一个元素到当前元素与平均值的差的和，因为题目要求不小于k个元素的最大平均值，所以当数数组中元素大于k个时，我们就要比较当前的差值与之之前的最小差值，如果这个值大于0，说明我们的平均值取消了，要向右取
3.这道题目比较难理解的点在这里:
>min_diff = Math.min(min_diff, sum[i - k + 1]);
i - j;

此处计算出sum[1],sum[2],sum[3]...sum[i-k]和0之间最小的一个值,这个值表示当前的n个元素和我们假设的最大平均数的差值之和, 然后在下一回合比较sum[i]和这个最小值的差,如果这个差值大于零,那就说明当前我们假设的最大平均值太小了
4.此题的核心要求简化思路,要求大于等于k长度的一个子数组的最大均值,从当前index回溯,去和之前所有子数组的最小值之和相减,那么就可以得出这个区间的最大差值,如果大于0,说明我们估计的平均值小了
5.关于min_diff为什么取0，sum[0] = 0,因为我们统计的是任意长度的字串，所以要考虑所有情况