```
@Copyright:LintCode
@Author:   zhou21
@Problem:  http://www.lintcode.com/problem/median-of-two-sorted-arrays
@Language: Markdown
@Datetime: 17-03-28 15:11
```

1. 可以用merge sort的解法解决,  复杂度为O(n)
2.  一旦涉及到log，那么肯定是采用二分的方法，这里，递归的执行一个辅助函数，每次分别在两个数组中, 我们需要寻找一个第k大的数，那么每次都将搜索范围缩小一半， 复杂度为log k，k = （m+n）/2
3. ** 具体思路如下，由于两个数组有序，那么要找到这两个数组中第K大的数，就是找出排在前K位的数字，那么从数组的起始位置开始计算，对于两个数组中前k/2个数，我们可以通过比较第k/2个数的值来排除掉k/2个数，如果A数组在这个位置上的值小于B，那么A数组在这个位置之前的值肯定都小于B在k/2的值，那么这些值就不可能成为第K大的数，可以用反证法，当A[i] < B[j]时， 此时A[i] < A[i + 1 : m] && A[i] < B[j + 1: n], 此时的i是k/2，那么利用反证法，就算此时B[0:k/2 -1]全部小于A[i]，那么A[i]也不可能成为第k个数，那么这之前的数全部都是第k个数之前，可以排除，那么就是在剩下的数组中找k-k/2个数**
4. 要注意corner case的处理，如果数组大小索引越界了，应该返回什么值，如果target = 1了，这个时候应该返回哪一个, 注意在求取k的值得时候，一定采用
`k = k - k/2`的形式，因为k/2是个整型，k不一定是even number，所以直接采用`k/2`可能导致索引值出❌