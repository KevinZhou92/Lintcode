```
@Copyright:LintCode
@Author:   zhou21
@Problem:  http://www.lintcode.com/problem/binary-tree-longest-consecutive-sequence-ii
@Language: Markdown
@Datetime: 17-02-05 21:39
```

1.思路和最长序列1很像，都是自定义数据类型记录前面的最大值，这里由于对方向不限制，我们每一个分支需要三个数据，向上的序列最大，向下的序列最大，以当前节点为根的子树中最长的一个序列
2.分治法，对每一个节点考虑时先分别计算左右两子树两个方向上的值，这两个值是异或的关系，有我没你，有你没我，取两子树同方向的最大值作为当前节点的最大值，最后计算max时只需要把不同方向的最大值加在一起即可得到当前最大值，然后分别和左右比较即可，这一步比较关键，也很有技巧，
3.此处的down和up分别记录升序或者降序的最长子串长度，如果左右子节点值均不连续，这两个值都为0，记录了在根节点之前，有几个连续的节点，也可以全部初始化为1，注意分清楚就可以